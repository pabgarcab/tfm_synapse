{
	"name": "3 - SilverToSCD2",
	"properties": {
		"activities": [
			{
				"name": "Delete SCD2 Folders",
				"type": "Delete",
				"dependsOn": [],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"dataset": {
						"referenceName": "dsSilverSCD",
						"type": "DatasetReference"
					},
					"enableLogging": false,
					"storeSettings": {
						"type": "AzureBlobFSReadSettings",
						"recursive": true,
						"enablePartitionDiscovery": false
					}
				}
			},
			{
				"name": "Load SCD2",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "Delete SCD2 Folders",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "ls_Severless",
					"type": "LinkedServiceReference",
					"parameters": {
						"DBName": "SilverlessSTG"
					}
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": "IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Articles') )\n    DROP EXTERNAL TABLE dim.Articles;\n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Articles]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Articles', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  AS idSkArticles,\n\t-1  AS idArticles,\n\t'D' AS name,\n\t'D' AS externalcode,\n\t'D' AS size,\n\t-1  AS numSize,\n\t'D' AS colour,\n\t'D' AS category, \n\t'D' AS codLine,\n\t'D' AS line, \n\t'D' AS description, \n\t'D' AS season,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-12-31' AS datetime2) AS toDate,\n\t1  AS isCurrent,\n\t19900101 AS loadDate,\n\t19900101 AS deltaDate,\n\tHASHBYTES('SHA2_256',('-1'+'D'+'D'+'D'+'-1'+'D'+'D'+'D'+'D'+'D'+'D')) AS [$hash]\nUNION\nSELECT *\nFROM [SilverlessSTG].[scd].[Articles]\n) a ORDER BY idSkArticles;\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Currency') )\n    DROP EXTERNAL TABLE dim.Currency;\n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Currency]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Currency', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkCurrency, \n\t-1  \t\t AS idCurrency, \n\t'D' \t\t AS name,\n\t'D' \t\t AS currency,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-12-31' AS datetime2)  AS toDate,\t\t\n\t1 \t\t\t AS isCurrent, \t\t \t\t\t \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + 'D' + 'D')) AS [$hash]\nUNION ALL\nSELECT *\nFROM [SilverlessSTG].[scd].[Currency]\n) C ORDER BY idSkCurrency;\n\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Date') )\n    DROP EXTERNAL TABLE dim.Date;\n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Date]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Date', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkDate, \n\t-1  \t\t AS idDate, \n\t-1 \t\t \t AS dateKey,\n\t'1990-01-01' AS date,\n\t'D'    \t     AS month, \n\t-1  \t\t AS monthNumber, \n\t-1 \t\t \t AS year,\n\t-1\t\t\t AS weekNumber,\n\t'D'    \t     AS dayWeek, \t\n\t-1\t\t\t AS dayWeekNumber, \n\t-1 \t\t \t AS yearDay,\n\t'D' \t\t AS quarter,\n\t'D'    \t     AS quadrimester, \t\n\t'D' \t\t AS semester, \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + '1990-01-01' + 'D' + '-1' + '-1' + '-1' + 'D' + '-1' + '-1' + 'D' + 'D' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idDate) AS idSkDate,\n\tidDate,\n\tdateKey,\n\tdate,\n\tmonth,\n\tmonthNumber,\n\tyear,\n\tweekNumber,\n\tdayWeek,\n\tdayWeekNumber,\n\tyearDay,\n\tquarter,\n\tquadrimester,\n\tsemester,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n        HASHBYTES('SHA2_256',(CAST(idDate AS NVARCHAR) + CAST(dateKey AS NVARCHAR) + CAST(date AS NVARCHAR) + month COLLATE DATABASE_DEFAULT + CAST(monthNumber AS NVARCHAR) + CAST(year AS NVARCHAR) \n        + CAST(weekNumber AS NVARCHAR) + dayWeek COLLATE DATABASE_DEFAULT + CAST(dayWeekNumber AS NVARCHAR) + CAST(yearDay AS NVARCHAR) + quarter + quadrimester + semester )) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_Date]\n) d ORDER BY idSkDate;\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Hours') )\n    DROP EXTERNAL TABLE dim.Hours;\n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Hours]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Hours', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkHours, \n\t-1  \t\t AS idHours, \n\t-1 \t\t \t AS hour,\n\t-1\t\t\t AS minute,\n\t'D'    \t     AS fullHour, \t \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + '-1' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idHours) AS idSkHours,\n\tidHours,\n\thour,\n\tminute,\n\tfullHour,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idHours AS NVARCHAR) + CAST(hour AS NVARCHAR) + CAST(minute AS NVARCHAR) + fullHour)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_Hours]\n) h ORDER BY idSkHours;\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.OperationType') )\n    DROP EXTERNAL TABLE dim.OperationType;\n\n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[OperationType]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/OperationType', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkOperationType , \n\t-1  \t\t AS idOperationType , \n\t'D' \t\t AS operation,\t\t\t \t\t\t \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idOperationType) AS idSkOperationType,\n\tidOperationType,\n\toperation,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idOperationType AS NVARCHAR) + operation)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_OperationType]\n) o ORDER BY idSkOperationType;\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.PostalCodes') )\n    DROP EXTERNAL TABLE dim.PostalCodes; \n\n\nCREATE  EXTERNAL TABLE [dim].[PostalCodes]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/PostalCodes', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkPostalCodes, \n\t-1  \t\t AS idpostalCode, \n\t'D' \t\t AS postalCodes,\n\t'D' \t\t AS region,\n\t'D' \t\t AS countryCode,\n\t'D' \t\t AS country,\t\t\t \t\t\t \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + 'D' + 'D' + 'D' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idPostalCodes) AS idSkPostalCodes,\n\tidPostalCodes,\n\tpostalCode,\n\tregion,\n\tcountryCode,\n\tcountry,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idPostalCodes AS NVARCHAR)+postalCode+region+countryCode+country)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_PostalCodes]\n) p ORDER BY idSkPostalCodes;\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Tariff') )\n    DROP EXTERNAL TABLE dim.Tariff;\n\nCREATE  EXTERNAL TABLE [dim].[Tariff]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Tariff', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkTariff, \n\t-1  \t\t AS idTariff, \n\t'D' \t\t AS tariff, \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idTariff) AS idSkTariff,\n\tidTariff,\n\ttariff,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idTariff AS NVARCHAR)+tariff)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_Tariff]\n) T ORDER BY idSkTariff\n\n\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Warehouse') )\n    DROP EXTERNAL TABLE dim.Warehouse; \n\n\nCREATE  EXTERNAL TABLE [dim].[Warehouse]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Warehouse', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM ( \nSELECT \n\t-1  \t\t AS idSkWarehouse, \n\t-1  \t\t AS idWarehouse, \n\t'D' \t\t AS warehouse, \n\t'D' \t\t AS externalcode, \n\t'D' \t\t AS countryCode, \n\t'D' \t\t AS country, \n\t'D' \t\t AS city, \n\t'D' \t\t AS address, \n\t'D' \t\t AS description, \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + 'D' + 'D' + 'D' + 'D' + 'D' + 'D'+ 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tidSkWarehouse,\n\tidWarehouse,\n\twarehouse,\n\texternalcode,\n\tcountryCode,\n\tcountry,\n\tcity,\n\taddress,\n\tdescription,  \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\tisCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idWarehouse AS NVARCHAR)+warehouse+externalcode+countryCode+country+city+address+description)) AS [$hash]\nFROM\n\t[SilverlessSTG].[scd].[Warehouse]\n) W ORDER BY idSkWarehouse;"
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			},
			{
				"name": "Delete Dimensions Folders",
				"type": "Delete",
				"dependsOn": [
					{
						"activity": "Load SCD2",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"typeProperties": {
					"dataset": {
						"referenceName": "dsGoldDimensions",
						"type": "DatasetReference"
					},
					"enableLogging": false,
					"storeSettings": {
						"type": "AzureBlobFSReadSettings",
						"recursive": true,
						"enablePartitionDiscovery": false
					}
				}
			},
			{
				"name": "Load Gold Dimensions",
				"type": "Script",
				"dependsOn": [
					{
						"activity": "Delete Dimensions Folders",
						"dependencyConditions": [
							"Succeeded"
						]
					}
				],
				"policy": {
					"timeout": "0.12:00:00",
					"retry": 0,
					"retryIntervalInSeconds": 30,
					"secureOutput": false,
					"secureInput": false
				},
				"userProperties": [],
				"linkedServiceName": {
					"referenceName": "ls_Severless",
					"type": "LinkedServiceReference",
					"parameters": {
						"DBName": "GoldenlessDWH"
					}
				},
				"typeProperties": {
					"scripts": [
						{
							"type": "NonQuery",
							"text": "---------------\n-- Articles  --\n---------------\n-- DROP EXTERNAL TABLE [dim].[Articles]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Articles') )\n    DROP EXTERNAL TABLE dim.Articles \n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Articles]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Articles', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  AS idSkArticles,\n\t-1  AS idArticles,\n\t'D' AS name,\n\t'D' AS externalcode,\n\t'D' AS size,\n\t-1  AS numSize,\n\t'D' AS colour,\n\t'D' AS category, \n\t'D' AS codLine,\n\t'D' AS line, \n\t'D' AS description, \n\t'D' AS season,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-12-31' AS datetime2) AS toDate,\n\t1  AS isCurrent,\n\t19900101 AS loadDate,\n\t19900101 AS deltaDate,\n\tHASHBYTES('SHA2_256',('-1'+'D'+'D'+'D'+'-1'+'D'+'D'+'D'+'D'+'D'+'D')) AS [$hash]\nUNION\nSELECT *\nFROM [SilverlessSTG].[scd].[Articles]\n) a ORDER BY idSkArticles\n\n\n--------------\n-- Currency --\n--------------\n-- DROP EXTERNAL TABLE [dim].[Currency]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Currency') )\n    DROP EXTERNAL TABLE dim.Currency \n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Currency]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Currency', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkCurrency, \n\t-1  \t\t AS idCurrency, \n\t'D' \t\t AS name,\n\t'D' \t\t AS currency,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-12-31' AS datetime2)  AS toDate,\t\t\n\t1 \t\t\t AS isCurrent, \t\t \t\t\t \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + 'D' + 'D')) AS [$hash]\nUNION ALL\nSELECT *\nFROM [SilverlessSTG].[scd].[Currency]\n) C ORDER BY idSkCurrency\n\n\n----------\n-- Date --\n----------\n-- DROP EXTERNAL TABLE [dim].[Date]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Date') )\n    DROP EXTERNAL TABLE dim.Date \n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Date]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Date', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkDate, \n\t-1  \t\t AS idDate, \n\t-1 \t\t \t AS dateKey,\n\t'1990-01-01' AS date,\n\t'D'    \t     AS month, \n\t-1  \t\t AS monthNumber, \n\t-1 \t\t \t AS year,\n\t-1\t\t\t AS weekNumber,\n\t'D'    \t     AS dayWeek, \t\n\t-1\t\t\t AS dayWeekNumber, \n\t-1 \t\t \t AS yearDay,\n\t'D' \t\t AS quarter,\n\t'D'    \t     AS quadrimester, \t\n\t'D' \t\t AS semester, \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + '1990-01-01' + 'D' + '-1' + '-1' + '-1' + 'D' + '-1' + '-1' + 'D' + 'D' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idDate) AS idSkDate,\n\tidDate,\n\tdateKey,\n\tdate,\n\tmonth,\n\tmonthNumber,\n\tyear,\n\tweekNumber,\n\tdayWeek,\n\tdayWeekNumber,\n\tyearDay,\n\tquarter,\n\tquadrimester,\n\tsemester,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n        HASHBYTES('SHA2_256',(CAST(idDate AS NVARCHAR) + CAST(dateKey AS NVARCHAR) + CAST(date AS NVARCHAR) + month COLLATE DATABASE_DEFAULT + CAST(monthNumber AS NVARCHAR) + CAST(year AS NVARCHAR) \n        + CAST(weekNumber AS NVARCHAR) + dayWeek COLLATE DATABASE_DEFAULT + CAST(dayWeekNumber AS NVARCHAR) + CAST(yearDay AS NVARCHAR) + quarter + quadrimester + semester )) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_Date]\n) d ORDER BY idSkDate\n\n-----------\n-- Hours --\n-----------\n-- DROP EXTERNAL TABLE [dim].[Hours]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Hours') )\n    DROP EXTERNAL TABLE dim.Hours \n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Hours]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Hours', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkHours, \n\t-1  \t\t AS idHours, \n\t-1 \t\t \t AS hour,\n\t-1\t\t\t AS minute,\n\t'D'    \t     AS fullHour, \t \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + '-1' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idHours) AS idSkHours,\n\tidHours,\n\thour,\n\tminute,\n\tfullHour,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idHours AS NVARCHAR) + CAST(hour AS NVARCHAR) + CAST(minute AS NVARCHAR) + fullHour)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_Hours]\n) h ORDER BY idSkHours\n\n-------------------\n-- OperationType --\n-------------------\n-- DROP EXTERNAL TABLE [dim].[OperationType]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.OperationType') )\n    DROP EXTERNAL TABLE dim.OperationType \nGO\n\nCREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[OperationType]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/OperationType', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkOperationType , \n\t-1  \t\t AS idOperationType , \n\t'D' \t\t AS operation,\t\t\t \t\t\t \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idOperationType) AS idSkOperationType,\n\tidOperationType,\n\toperation,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idOperationType AS NVARCHAR) + operation)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_OperationType]\n) o ORDER BY idSkOperationType\n\n-----------------\n-- PostalCodes --\n-----------------\n--DROP EXTERNAL TABLE [dim].[PostalCodes]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.PostalCodes') )\n    DROP EXTERNAL TABLE dim.PostalCodes \nGO\n\nCREATE  EXTERNAL TABLE [dim].[PostalCodes]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/PostalCodes', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkPostalCodes, \n\t-1  \t\t AS idpostalCode, \n\t'D' \t\t AS postalCodes,\n\t'D' \t\t AS region,\n\t'D' \t\t AS countryCode,\n\t'D' \t\t AS country,\t\t\t \t\t\t \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + 'D' + 'D' + 'D' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idPostalCodes) AS idSkPostalCodes,\n\tidPostalCodes,\n\tpostalCode,\n\tregion,\n\tcountryCode,\n\tcountry,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idPostalCodes AS NVARCHAR)+postalCode+region+countryCode+country)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_PostalCodes]\n) p ORDER BY idSkPostalCodes\n\n------------\n-- Tariff --\n------------\n-- DROP EXTERNAL TABLE [dim].[Tariff]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Tariff') )\n    DROP EXTERNAL TABLE dim.Tariff \n\nCREATE  EXTERNAL TABLE [dim].[Tariff]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Tariff', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM (\nSELECT \n\t-1  \t\t AS idSkTariff, \n\t-1  \t\t AS idTariff, \n\t'D' \t\t AS tariff, \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tROW_NUMBER () OVER (ORDER BY idTariff) AS idSkTariff,\n\tidTariff,\n\ttariff,\n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 isCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idTariff AS NVARCHAR)+tariff)) AS [$hash]\nFROM\n\t[SilverlessSTG].[etl].[vw_dim_Tariff]\n) T ORDER BY idSkTariff\n\n---------------\n-- Warehouse --\n---------------\n-- DROP EXTERNAL TABLE [dim].[Warehouse]\nIF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Warehouse') )\n    DROP EXTERNAL TABLE dim.Warehouse \nGO\n\nCREATE  EXTERNAL TABLE [dim].[Warehouse]\nWITH\n(\n\tLOCATION = 'gold/Dimensions/Warehouse', \n\tDATA_SOURCE = datalake1pgc,\n\tFILE_FORMAT = ParquetFileFormat\n) AS \nSELECT * FROM ( \nSELECT \n\t-1  \t\t AS idSkWarehouse, \n\t-1  \t\t AS idWarehouse, \n\t'D' \t\t AS warehouse, \n\t'D' \t\t AS externalcode, \n\t'D' \t\t AS countryCode, \n\t'D' \t\t AS country, \n\t'D' \t\t AS city, \n\t'D' \t\t AS address, \n\t'D' \t\t AS description, \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\t1 \t\t\t AS isCurrent, \n\t19900101 \t AS loadDate, \n\t19900101 \t AS deltaDate, \n\tHASHBYTES('SHA2_256',('-1' + '-1' + 'D' + 'D' + 'D' + 'D' + 'D' + 'D'+ 'D')) AS [$hash]\n\nUNION\n\nSELECT \n\tidSkWarehouse,\n\tidWarehouse,\n\twarehouse,\n\texternalcode,\n\tcountryCode,\n\tcountry,\n\tcity,\n\taddress,\n\tdescription,  \n\tCAST('1990-01-01' AS datetime2) AS fromDate,\n\tCAST('9999-01-01' AS datetime2) AS toDate,\n\tisCurrent,\n\tloadDate,\n\tdeltaDate,\n\tHASHBYTES('SHA2_256',(CAST(idWarehouse AS NVARCHAR)+warehouse+externalcode+countryCode+country+city+address+description)) AS [$hash]\nFROM\n\t[SilverlessSTG].[scd].[Warehouse]\n) W ORDER BY idSkWarehouse"
						}
					],
					"scriptBlockExecutionTimeout": "02:00:00"
				}
			}
		],
		"parameters": {
			"queryReloadSCD": {
				"type": "string",
				"defaultValue": "--------------- -- Articles -- --------------- -- DROP EXTERNAL TABLE  scd.Articles IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Articles') )     DROP EXTERNAL TABLE scd.Articles  GO  CREATE EXTERNAL TABLE  scd.Articles  WITH ( \tLOCATION = 'silver/SCD/Articles',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[Articles]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*, \t    HASHBYTES('SHA2_256',(CAST(s.idArticles AS NVARCHAR)+ s.name + s.description COLLATE DATABASE_DEFAULT + s.externalcode + s.size + CAST(s.numSize AS NVARCHAR) + s.colour + s.category + s.codLine + s.line + s.season)) AS [$hash]     FROM etl.vw_dim_Articles s     LEFT JOIN current_data c         ON s.idArticles = c.idArticles ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkArticles), 0) AS max_key     FROM [GoldenlessDWH].[dim].[Articles] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idArticles) + max_key AS new_idSkArticles, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idArticles = c.idArticles     CROSS JOIN max_surrogate_key     WHERE c.idArticles IS NULL  OR (c.[$hash] != chg.[$hash] ) ), --select * from new_or_updated_data order by idarticles -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkarticles AS new_idSkArticles,         c.idArticles,         c.name,         c.externalCode,         c.size,         c.numSize,         c.colour,         c.category,         c.codLine,         c.line,         c.description,         c.season,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idArticles = chg.idArticles     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkArticles, -- Mantener la clave subrogada original     c.idArticles,     c.name,     c.externalCode,     c.size,     c.numSize,     c.colour,     c.category,     c.codLine,     c.line,     c.description,     c.season,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idArticles = chg.idArticles WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkArticles,      idArticles,     name,     externalCode,     size,     numSize,     colour,     category,     codLine,     line,     description,     season,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkArticles,      idArticles,     name,     externalCode,     size,     numSize,     colour,     category,     codLine,     line,     description,     season,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkArticles; GO   --------------- -- Currency -- --------------- -- DROP EXTERNAL TABLE  scd.Currency IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Currency') )     DROP EXTERNAL TABLE scd.Currency   GO  CREATE EXTERNAL TABLE  scd.Currency  WITH ( \tLOCATION = 'silver/SCD/Currency',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS   WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[Currency]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*,         HASHBYTES('SHA2_256',(CAST(s.idCurrency AS NVARCHAR) + s.name + s.currency)) AS [$hash]     FROM etl.vw_dim_Currency s     LEFT JOIN current_data c         ON s.idCurrency = c.idCurrency ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkCurrency), 0) AS max_key     FROM [GoldenlessDWH].[dim].[Currency] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idCurrency) + max_key AS new_idSkCurrency, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idCurrency = c.idCurrency     CROSS JOIN max_surrogate_key     WHERE c.idCurrency IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkCurrency AS new_idSkCurrency,         c.idCurrency,         c.name,         c.currency,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idCurrency = chg.idCurrency     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkCurrency, -- Mantener la clave subrogada original     c.idCurrency,     c.name,     c.currency,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idCurrency = chg.idCurrency WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkCurrency,      idCurrency,     name,     currency,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkCurrency,      idCurrency,     name,     currency,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkCurrency; GO   ------------ -- Client -- ------------ -- DROP EXTERNAL TABLE  scd.Client -- IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Client') ) --    DROP EXTERNAL TABLE scd.Client    -- GO  -- CREATE EXTERNAL TABLE  scd.Client  -- WITH -- ( -- \tLOCATION = 'silver/SCD/Client',  -- \tDATA_SOURCE = datalake1pgc, -- \tFILE_FORMAT = ParquetFileFormat -- ) AS  -- WITH current_data AS ( --     SELECT * --     FROM [GoldenlessDWH].[dim].[Currency] --     WHERE isCurrent = 1 -- ), -- -- Identificar los registros que han cambiado o son nuevos -- changes AS ( --     SELECT --         s.*, --         HASHBYTES('SHA2_256',(CAST(s.idCurrency AS NVARCHAR) + s.name + s.currency)) AS [$hash] --     FROM etl.vw_dim_Currency s --     LEFT JOIN current_data c --         ON s.idCurrency = c.idCurrency -- ), -- -- Obtener el valor máximo de la clave subrogada existente en la tabla -- max_surrogate_key AS ( --     SELECT COALESCE(MAX(idSkCurrency), 0) AS max_key --     FROM [GoldenlessDWH].[dim].[Currency] -- ), -- -- Calcular claves subrogadas para los registros nuevos o modificados -- new_or_updated_data AS ( --     SELECT --         ROW_NUMBER() OVER (ORDER BY chg.idCurrency) + max_key AS new_idSkCurrency, -- Asignar nueva clave subrogada --         chg.*, --         1 AS isCurrent, --         GETDATE() AS fromDate, --         '9999-12-31' AS toDate --     FROM changes chg --     LEFT JOIN current_data c --         ON chg.idCurrency = c.idCurrency --     CROSS JOIN max_surrogate_key --     WHERE c.idCurrency IS NULL  OR (c.[$hash] != chg.[$hash] ) -- ), -- -- Obtener los registros que no han cambiado (mantener clave subrogada) -- unchanged_data AS ( --     SELECT --         c.idSkCurrency AS new_idSkCurrency, --         c.idCurrency, --         c.name, --         c.currency, --         c.fromDate, --         c.toDate, --         c.isCurrent, --         c.loadDate, --         c.deltaDate, --         c.[$hash] --     FROM current_data c --     JOIN changes chg --         ON c.idCurrency = chg.idCurrency --     -- Seleccionar solo las filas que no han cambiado --     WHERE c.[$hash] = chg.[$hash] -- ), -- -- Unión final con las versiones antiguas, actualizadas y sin cambios -- final AS ( -- SELECT --     c.idSkCurrency, -- Mantener la clave subrogada original --     c.idCurrency, --     c.name, --     c.currency, --     c.fromDate, --     GETDATE() AS toDate, --     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales --     c.loadDate, --     c.deltaDate, --     c.[$hash] -- FROM current_data c -- JOIN changes chg --     ON c.idCurrency = chg.idCurrency -- WHERE c.[$hash] != chg.[$hash]  -- UNION ALL  -- -- Insertar los registros nuevos o modificados con nuevas claves subrogadas -- SELECT --     new_idSkCurrency,  --     idCurrency, --     name, --     currency, --     fromDate, --     toDate, --     isCurrent, --     loadDate, --     deltaDate, --     [$hash] -- FROM new_or_updated_data  -- UNION ALL  -- -- Insertar los registros que no han cambiado -- SELECT --     new_idSkCurrency,  --     idCurrency, --     name, --     currency, --     fromDate, --     toDate, --     isCurrent, --     loadDate, --     deltaDate, --     [$hash] -- FROM unchanged_data -- ) -- SELECT      --     *  -- FROM final -- ORDER BY idSkCurrency; -- GO  ---------- -- Date -- ---------- --DROP EXTERNAL TABLE  scd.Date  IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Date') )    DROP EXTERNAL TABLE scd.Date   GO  CREATE EXTERNAL TABLE  scd.Date  WITH ( \tLOCATION = 'silver/SCD/Date',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[Date]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*,         HASHBYTES('SHA2_256',(CAST(s.idDate AS NVARCHAR) + CAST(s.dateKey AS NVARCHAR) + CAST(s.date AS NVARCHAR) + s.month COLLATE DATABASE_DEFAULT + CAST(s.monthNumber AS NVARCHAR) + CAST(s.year AS NVARCHAR)          + CAST(s.weekNumber AS NVARCHAR) + s.dayWeek COLLATE DATABASE_DEFAULT + CAST(s.dayWeekNumber AS NVARCHAR) + CAST(s.yearDay AS NVARCHAR) + s.quarter + s.quadrimester + s.semester )) AS [$hash]     FROM etl.vw_dim_Date s     LEFT JOIN current_data c         ON s.idDate = c.idDate ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkDate), 0) AS max_key     FROM [GoldenlessDWH].[dim].[Date] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idDate) + max_key AS new_idSkDate, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idDate = c.idDate     CROSS JOIN max_surrogate_key     WHERE c.idDate IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkDate AS new_idSkDate,         c.idDate,         c.dateKey,         c.date,         c.month,         c.monthNumber,         c.year,         c.weekNumber,         c.dayWeek,         c.dayWeekNumber,         c.yearDay,         c.quarter,         c.quadrimester,         c.semester,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idDate = chg.idDate     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkDate, -- Mantener la clave subrogada original     c.idDate, \tc.dateKey, \tc.date, \tc.month, \tc.monthNumber, \tc.year, \tc.weekNumber, \tc.dayWeek, \tc.dayWeekNumber, \tc.yearDay, \tc.quarter, \tc.quadrimester, \tc.semester,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idDate = chg.idDate WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkDate,      idDate, \tdateKey, \tdate, \tmonth, \tmonthNumber, \tyear, \tweekNumber, \tdayWeek, \tdayWeekNumber, \tyearDay, \tquarter, \tquadrimester, \tsemester,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkDate,      idDate, \tdateKey, \tdate, \tmonth, \tmonthNumber, \tyear, \tweekNumber, \tdayWeek, \tdayWeekNumber, \tyearDay, \tquarter, \tquadrimester, \tsemester,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkDate; GO   --------------- -- Hours -- --------------- -- DROP EXTERNAL TABLE  scd.Hours IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Hours') )    DROP EXTERNAL TABLE scd.Hours    GO  CREATE EXTERNAL TABLE  scd.Hours  WITH ( \tLOCATION = 'silver/SCD/Hours',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS   WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[Hours]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*,         HASHBYTES('SHA2_256',(CAST(s.idHours AS NVARCHAR) + CAST(s.hour AS NVARCHAR) + CAST(s.minute AS NVARCHAR) + s.fullHour)) AS [$hash]     FROM etl.vw_dim_Hours s     LEFT JOIN current_data c         ON s.idHours = c.idHours ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkHours), 0) AS max_key     FROM [GoldenlessDWH].[dim].[Hours] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idHours) + max_key AS new_idSkHours, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idHours = c.idHours     CROSS JOIN max_surrogate_key     WHERE c.idHours IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkHours AS new_idSkHours,         c.idHours,         c.hour,         c.minute,         c.fullHour,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idHours = chg.idHours     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkHours, -- Mantener la clave subrogada original \tc.idHours, \tc.hour, \tc.minute, \tc.fullHour,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idHours = chg.idHours WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkHours,  \tidHours, \thour, \tminute, \tfullHour,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkHours,  \tidHours, \thour, \tminute, \tfullHour,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkHours; GO   ------------------- -- OperationType -- ------------------- -- DROP EXTERNAL TABLE  scd.OperationType  IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.OperationType') )    DROP EXTERNAL TABLE scd.OperationType    GO  CREATE EXTERNAL TABLE  scd.OperationType  WITH ( \tLOCATION = 'silver/SCD/OperationType',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS   WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[OperationType]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*, \t    HASHBYTES('SHA2_256',(CAST(s.idOperationType AS NVARCHAR) + s.operation)) AS [$hash]     FROM etl.vw_dim_OperationType s     LEFT JOIN current_data c         ON s.idOperationType = c.idOperationType ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkOperationType), 0) AS max_key     FROM [GoldenlessDWH].[dim].[OperationType] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idOperationType) + max_key AS new_idSkOperationType, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idOperationType = c.idOperationType     CROSS JOIN max_surrogate_key     WHERE c.idOperationType IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkOperationType AS new_idSkOperationType,         c.idOperationType,         c.operation,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idOperationType = chg.idOperationType     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkOperationType, -- Mantener la clave subrogada original     c.idOperationType,     c.operation,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idOperationType = chg.idOperationType WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkOperationType,     idOperationType,     operation,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkOperationType,      idOperationType,     operation,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkOperationType; GO   ----------------- -- PostalCodes -- ----------------- --DROP EXTERNAL TABLE  scd.PostalCodes  IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.PostalCodes') )     DROP EXTERNAL TABLE scd.PostalCodes  GO  GO  CREATE EXTERNAL TABLE  scd.PostalCodes  WITH ( \tLOCATION = 'silver/SCD/PostalCodes',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[PostalCodes]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*,         HASHBYTES('SHA2_256',(CAST(s.idPostalCodes AS NVARCHAR) + s.postalCode + s.region + s.countryCode + s.country)) AS [$hash]     FROM etl.vw_dim_PostalCodes s     LEFT JOIN current_data c         ON s.idPostalCodes = c.idPostalCodes ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkPostalCodes), 0) AS max_key     FROM [GoldenlessDWH].[dim].[PostalCodes] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idPostalCodes) + max_key AS new_idSkPostalCodes, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idPostalCodes = c.idPostalCodes     CROSS JOIN max_surrogate_key     WHERE c.idPostalCodes IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkPostalCodes AS new_idSkPostalCodes,         c.idPostalCodes,         c.postalCode,         c.region,         c.countryCode,         c.country,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idPostalCodes = chg.idPostalCodes     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkPostalCodes, -- Mantener la clave subrogada original     c.idPostalCodes,     c.postalCode,     c.region,     c.countryCode,     c.country,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idPostalCodes = chg.idPostalCodes WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkPostalCodes,     idPostalCodes,     postalCode,     region,     countryCode,     country,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkPostalCodes,      idPostalCodes,     postalCode,     region,     countryCode,     country,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkPostalCodes; GO   ------------ -- Tariff -- ------------ --DROP EXTERNAL TABLE  scd.Tariff  IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Tariff') )    DROP EXTERNAL TABLE scd.Tariff    GO  CREATE EXTERNAL TABLE  scd.Tariff  WITH ( \tLOCATION = 'silver/SCD/Tariff',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[Tariff]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.*,         HASHBYTES('SHA2_256',(CAST(s.idTariff AS NVARCHAR) + s.tariff)) AS [$hash]     FROM etl.vw_dim_Tariff s     LEFT JOIN current_data c         ON s.idTariff = c.idTariff ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkTariff), 0) AS max_key     FROM [GoldenlessDWH].[dim].[Tariff] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idTariff) + max_key AS new_idSkTariff, -- Asignar nueva clave subrogada         chg.*,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate     FROM changes chg     LEFT JOIN current_data c         ON chg.idTariff = c.idTariff     CROSS JOIN max_surrogate_key     WHERE c.idTariff IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkTariff AS new_idSkTariff,         c.idTariff,         c.tariff,         c.fromDate,         c.toDate,         c.isCurrent,         c.loadDate,         c.deltaDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idTariff = chg.idTariff     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), -- Unión final con las versiones antiguas, actualizadas y sin cambios final AS ( SELECT     c.idSkTariff, -- Mantener la clave subrogada original     c.idTariff,     c.tariff,     c.fromDate,     GETDATE() AS toDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.loadDate,     c.deltaDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idTariff = chg.idTariff WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkTariff,      idTariff,     tariff,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkTariff,      idTariff,     tariff,     fromDate,     toDate,     isCurrent,     loadDate,     deltaDate,     [$hash] FROM unchanged_data ) SELECT          *  FROM final ORDER BY idSkTariff; GO   --------------- -- Warehouse -- --------------- -- DROP EXTERNAL TABLE  scd.Warehouse  IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('scd.Warehouse') )    DROP EXTERNAL TABLE scd.Warehouse    GO  CREATE EXTERNAL TABLE  scd.Warehouse  WITH ( \tLOCATION = 'silver/SCD/Warehouse',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS   WITH current_data AS (     SELECT *     FROM [GoldenlessDWH].[dim].[Warehouse]     WHERE isCurrent = 1 ), -- Identificar los registros que han cambiado o son nuevos changes AS (     SELECT         s.idWarehouse,         s.warehouse,         s.externalCode,         s.countryCode,         s.country,         s.city,         s.address,         s.description,         s.loadDate,         s.deltaDate,         HASHBYTES('SHA2_256',(CAST(s.idWarehouse AS NVARCHAR) + s.warehouse + s.externalcode + s.countryCode + s.country + s.city + s.address + s.description)) AS [$hash]     FROM etl.vw_dim_Warehouse s     LEFT JOIN current_data c         ON s.idWarehouse = c.idWarehouse ), -- Obtener el valor máximo de la clave subrogada existente en la tabla max_surrogate_key AS (     SELECT COALESCE(MAX(idSkWarehouse), 0) AS max_key     FROM [GoldenlessDWH].[dim].[Warehouse] ), -- Calcular claves subrogadas para los registros nuevos o modificados new_or_updated_data AS (     SELECT         ROW_NUMBER() OVER (ORDER BY chg.idWarehouse) + max_key AS new_idSkWarehouse, -- Asignar nueva clave subrogada         chg.idWarehouse,         chg.warehouse,         chg.externalCode,         chg.countryCode,         chg.country,         chg.city,         chg.address,         chg.description,         chg.loadDate,         chg.deltaDate,         1 AS isCurrent,         GETDATE() AS fromDate,         '9999-12-31' AS toDate,         chg.[$hash]     FROM changes chg     LEFT JOIN current_data c         ON chg.idWarehouse = c.idWarehouse     CROSS JOIN max_surrogate_key     WHERE c.idWarehouse IS NULL  OR (c.[$hash] != chg.[$hash] ) ), -- Obtener los registros que no han cambiado (mantener clave subrogada) unchanged_data AS (     SELECT         c.idSkWarehouse AS new_idSkWarehouse,         c.idWarehouse,         c.warehouse,         c.externalCode,         c.countryCode,         c.country,         c.city,         c.address,         c.description,         c.loadDate,         c.deltaDate,         c.isCurrent,         c.fromDate,         c.toDate,         c.[$hash]     FROM current_data c     JOIN changes chg         ON c.idWarehouse = chg.idWarehouse     -- Seleccionar solo las filas que no han cambiado     WHERE c.[$hash] = chg.[$hash] ), final AS ( -- Unión final con las versiones antiguas, actualizadas y sin cambios SELECT     c.idSkWarehouse, -- Mantener la clave subrogada original     c.idWarehouse,     c.warehouse,     c.externalCode,     c.countryCode,     c.country,     c.city,     c.address,     c.description,     c.loadDate,     c.deltaDate,     0 AS isCurrent, -- Marcar las versiones antiguas como no actuales     c.fromDate,     GETDATE() AS toDate,     c.[$hash] FROM current_data c JOIN changes chg     ON c.idWarehouse = chg.idWarehouse WHERE c.[$hash] != chg.[$hash]  UNION ALL  -- Insertar los registros nuevos o modificados con nuevas claves subrogadas SELECT     new_idSkWarehouse,      idWarehouse,     warehouse,     externalCode,     countryCode,     country,     city,     address,     description,     loadDate,     deltaDate,     isCurrent,     fromDate,     toDate,     [$hash] FROM new_or_updated_data  UNION ALL  -- Insertar los registros que no han cambiado SELECT     new_idSkWarehouse,      idWarehouse,     warehouse,     externalCode,     countryCode,     country,     city,     address,     description,     loadDate,     deltaDate,     isCurrent,     fromDate,     toDate,     [$hash] FROM unchanged_data  ) select     idSkWarehouse,      idWarehouse,     warehouse,     externalCode,     countryCode,     country,     city,     address,     description,     loadDate,     deltaDate,     isCurrent,     fromDate,     toDate,     [$hash] FROM final ORDER BY idSkWarehouse;"
			},
			"queryReloadGoldCETAs": {
				"type": "string",
				"defaultValue": "--------------- -- Articles  -- --------------- -- DROP EXTERNAL TABLE [dim].[Articles] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Articles') )     DROP EXTERNAL TABLE dim.Articles   CREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Articles] WITH ( \tLOCATION = 'gold/Dimensions/Articles',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  AS idSkArticles, \t-1  AS idArticles, \t'D' AS name, \t'D' AS externalcode, \t'D' AS size, \t-1  AS numSize, \t'D' AS colour, \t'D' AS category,  \t'D' AS codLine, \t'D' AS line,  \t'D' AS description,  \t'D' AS season, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-12-31' AS datetime2) AS toDate, \t1  AS isCurrent, \t19900101 AS loadDate, \t19900101 AS deltaDate, \tHASHBYTES('SHA2_256',('-1'+'D'+'D'+'D'+'-1'+'D'+'D'+'D'+'D'+'D'+'D')) AS [$hash] UNION SELECT * FROM [SilverlessSTG].[scd].[Articles] ) a ORDER BY idSkArticles   -------------- -- Currency -- -------------- -- DROP EXTERNAL TABLE [dim].[Currency] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Currency') )     DROP EXTERNAL TABLE dim.Currency   CREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Currency] WITH ( \tLOCATION = 'gold/Dimensions/Currency',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  \t\t AS idSkCurrency,  \t-1  \t\t AS idCurrency,  \t'D' \t\t AS name, \t'D' \t\t AS currency, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-12-31' AS datetime2)  AS toDate,\t\t \t1 \t\t\t AS isCurrent, \t\t \t\t\t  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + 'D' + 'D')) AS [$hash] UNION ALL SELECT * FROM [SilverlessSTG].[scd].[Currency] ) C ORDER BY idSkCurrency   ---------- -- Date -- ---------- -- DROP EXTERNAL TABLE [dim].[Date] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Date') )     DROP EXTERNAL TABLE dim.Date   CREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Date] WITH ( \tLOCATION = 'gold/Dimensions/Date',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  \t\t AS idSkDate,  \t-1  \t\t AS idDate,  \t-1 \t\t \t AS dateKey, \t'1990-01-01' AS date, \t'D'    \t     AS month,  \t-1  \t\t AS monthNumber,  \t-1 \t\t \t AS year, \t-1\t\t\t AS weekNumber, \t'D'    \t     AS dayWeek, \t \t-1\t\t\t AS dayWeekNumber,  \t-1 \t\t \t AS yearDay, \t'D' \t\t AS quarter, \t'D'    \t     AS quadrimester, \t \t'D' \t\t AS semester,  \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 \t\t\t AS isCurrent,  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + '-1' + '1990-01-01' + 'D' + '-1' + '-1' + '-1' + 'D' + '-1' + '-1' + 'D' + 'D' + 'D')) AS [$hash]  UNION  SELECT  \tROW_NUMBER () OVER (ORDER BY idDate) AS idSkDate, \tidDate, \tdateKey, \tdate, \tmonth, \tmonthNumber, \tyear, \tweekNumber, \tdayWeek, \tdayWeekNumber, \tyearDay, \tquarter, \tquadrimester, \tsemester, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 isCurrent, \tloadDate, \tdeltaDate,         HASHBYTES('SHA2_256',(CAST(idDate AS NVARCHAR) + CAST(dateKey AS NVARCHAR) + CAST(date AS NVARCHAR) + month COLLATE DATABASE_DEFAULT + CAST(monthNumber AS NVARCHAR) + CAST(year AS NVARCHAR)          + CAST(weekNumber AS NVARCHAR) + dayWeek COLLATE DATABASE_DEFAULT + CAST(dayWeekNumber AS NVARCHAR) + CAST(yearDay AS NVARCHAR) + quarter + quadrimester + semester )) AS [$hash] FROM \t[SilverlessSTG].[etl].[vw_dim_Date] ) d ORDER BY idSkDate  ----------- -- Hours -- ----------- -- DROP EXTERNAL TABLE [dim].[Hours] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Hours') )     DROP EXTERNAL TABLE dim.Hours   CREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[Hours] WITH ( \tLOCATION = 'gold/Dimensions/Hours',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  \t\t AS idSkHours,  \t-1  \t\t AS idHours,  \t-1 \t\t \t AS hour, \t-1\t\t\t AS minute, \t'D'    \t     AS fullHour, \t  \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 \t\t\t AS isCurrent,  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + '-1' + '-1' + 'D')) AS [$hash]  UNION  SELECT  \tROW_NUMBER () OVER (ORDER BY idHours) AS idSkHours, \tidHours, \thour, \tminute, \tfullHour, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 isCurrent, \tloadDate, \tdeltaDate, \tHASHBYTES('SHA2_256',(CAST(idHours AS NVARCHAR) + CAST(hour AS NVARCHAR) + CAST(minute AS NVARCHAR) + fullHour)) AS [$hash] FROM \t[SilverlessSTG].[etl].[vw_dim_Hours] ) h ORDER BY idSkHours  ------------------- -- OperationType -- ------------------- -- DROP EXTERNAL TABLE [dim].[OperationType] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.OperationType') )     DROP EXTERNAL TABLE dim.OperationType  GO  CREATE  EXTERNAL TABLE GoldenlessDWH.[dim].[OperationType] WITH ( \tLOCATION = 'gold/Dimensions/OperationType',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  \t\t AS idSkOperationType ,  \t-1  \t\t AS idOperationType ,  \t'D' \t\t AS operation,\t\t\t \t\t\t  \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 \t\t\t AS isCurrent,  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + 'D')) AS [$hash]  UNION  SELECT  \tROW_NUMBER () OVER (ORDER BY idOperationType) AS idSkOperationType, \tidOperationType, \toperation, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 isCurrent, \tloadDate, \tdeltaDate, \tHASHBYTES('SHA2_256',(CAST(idOperationType AS NVARCHAR) + operation)) AS [$hash] FROM \t[SilverlessSTG].[etl].[vw_dim_OperationType] ) o ORDER BY idSkOperationType  ----------------- -- PostalCodes -- ----------------- --DROP EXTERNAL TABLE [dim].[PostalCodes] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.PostalCodes') )     DROP EXTERNAL TABLE dim.PostalCodes  GO  CREATE  EXTERNAL TABLE [dim].[PostalCodes] WITH ( \tLOCATION = 'gold/Dimensions/PostalCodes',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  \t\t AS idSkPostalCodes,  \t-1  \t\t AS idpostalCode,  \t'D' \t\t AS postalCodes, \t'D' \t\t AS region, \t'D' \t\t AS countryCode, \t'D' \t\t AS country,\t\t\t \t\t\t  \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 \t\t\t AS isCurrent,  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + '-1' + 'D' + 'D' + 'D' + 'D')) AS [$hash]  UNION  SELECT  \tROW_NUMBER () OVER (ORDER BY idPostalCodes) AS idSkPostalCodes, \tidPostalCodes, \tpostalCode, \tregion, \tcountryCode, \tcountry, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 isCurrent, \tloadDate, \tdeltaDate, \tHASHBYTES('SHA2_256',(CAST(idPostalCodes AS NVARCHAR)+postalCode+region+countryCode+country)) AS [$hash] FROM \t[SilverlessSTG].[etl].[vw_dim_PostalCodes] ) p ORDER BY idSkPostalCodes  ------------ -- Tariff -- ------------ -- DROP EXTERNAL TABLE [dim].[Tariff] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Tariff') )     DROP EXTERNAL TABLE dim.Tariff   CREATE  EXTERNAL TABLE [dim].[Tariff] WITH ( \tLOCATION = 'gold/Dimensions/Tariff',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM ( SELECT  \t-1  \t\t AS idSkTariff,  \t-1  \t\t AS idTariff,  \t'D' \t\t AS tariff,  \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 \t\t\t AS isCurrent,  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + 'D')) AS [$hash]  UNION  SELECT  \tROW_NUMBER () OVER (ORDER BY idTariff) AS idSkTariff, \tidTariff, \ttariff, \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 isCurrent, \tloadDate, \tdeltaDate, \tHASHBYTES('SHA2_256',(CAST(idTariff AS NVARCHAR)+tariff)) AS [$hash] FROM \t[SilverlessSTG].[etl].[vw_dim_Tariff] ) T ORDER BY idSkTariff  --------------- -- Warehouse -- --------------- -- DROP EXTERNAL TABLE [dim].[Warehouse] IF EXISTS ( SELECT * FROM sys.external_tables WHERE object_id = OBJECT_ID('dim.Warehouse') )     DROP EXTERNAL TABLE dim.Warehouse  GO  CREATE  EXTERNAL TABLE [dim].[Warehouse] WITH ( \tLOCATION = 'gold/Dimensions/Warehouse',  \tDATA_SOURCE = datalake1pgc, \tFILE_FORMAT = ParquetFileFormat ) AS  SELECT * FROM (  SELECT  \t-1  \t\t AS idSkWarehouse,  \t-1  \t\t AS idWarehouse,  \t'D' \t\t AS warehouse,  \t'D' \t\t AS externalcode,  \t'D' \t\t AS countryCode,  \t'D' \t\t AS country,  \t'D' \t\t AS city,  \t'D' \t\t AS address,  \t'D' \t\t AS description,  \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \t1 \t\t\t AS isCurrent,  \t19900101 \t AS loadDate,  \t19900101 \t AS deltaDate,  \tHASHBYTES('SHA2_256',('-1' + '-1' + 'D' + 'D' + 'D' + 'D' + 'D' + 'D'+ 'D')) AS [$hash]  UNION  SELECT  \tidSkWarehouse, \tidWarehouse, \twarehouse, \texternalcode, \tcountryCode, \tcountry, \tcity, \taddress, \tdescription,   \tCAST('1990-01-01' AS datetime2) AS fromDate, \tCAST('9999-01-01' AS datetime2) AS toDate, \tisCurrent, \tloadDate, \tdeltaDate, \tHASHBYTES('SHA2_256',(CAST(idWarehouse AS NVARCHAR)+warehouse+externalcode+countryCode+country+city+address+description)) AS [$hash] FROM \t[SilverlessSTG].[scd].[Warehouse] ) W ORDER BY idSkWarehouse"
			}
		},
		"annotations": [],
		"lastPublishTime": "2024-09-14T15:15:28Z"
	},
	"type": "Microsoft.Synapse/workspaces/pipelines"
}